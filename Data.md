# 데이터 갖고놀기
## 정수
### 기본정보
- 참고 : "//(내용입력)" 혹은 "/*(내용입력)*/"을 통해 주석을 입력할 수 있다.
- 정수 : 소수점을 포함하지 않은 양수(자연수), 0, 음수의 집합
- 변수 : 데이터를 저장하는 일종의 용기

### 정수에서 변수의 이용
- "int(변수의 타입) (변수의 이름) = ("변수의 이름"에 들어갈 값, =과 함께 생략가능);(;=코드의 줄이 끝났음을 알려주는 표시)"
- 예시1 : int hp; / hp = 100;
- 예시2 : int hp = 100;
- 변수의 호출 : Console.WriteLine에 ('hello number! {0}", hp);를 입력하면 {0}부분에 해당 변수에 저장된 데이터를 삽입한다.

### 변수의 저장변수타입
- 본 형태 : byte(1바이트, 0\~255), short(2바이트, -30,000\~30,000), int(4바이트, -21억\~21억), long(8바이트, (음수를 포함함))
- 바리에이션 : sbyte(1바이트, -128\~127), ushort(2바이트, 0\~60,000), uint(4바이트, 0억\~43억), ulong(8바이트, (음수포함안함))
- 프로그램 실행 시(혹은 네트워크 교신 시) 차지하는 메모리의 부하를 감소시키기 위해 다양한 저장변수타입을 사용한다.
- 오버플로우 : byte에서 값이 0미만으로 떨어질 경우 한바퀴를 돌아 그 값의 최대값이 255로 변한다.

## 진수
- 10진수 : 한 자리에서 표현할 수 있는 숫자는 0~9까지이다. (00 01 02 03 04 05 06 07 08 09)
- 2진수 : 한 자리에서 표현할 수 있는 숫자는 0~1까지이다. 10진수와 구별하기 위해서 숫자 앞에 "0b"를 적는다. (0b00 0b01 0b10 0b11...)
- 16진수 : 한 자리에서 표현할 수 있는 숫자는 0~15까지이다. 10진수와 구별하기 위해 숫자 앞에 "0x"를 적는다. (0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a(10) 0x0b(11) 0x0c(12) 0x0d(13) 0x0e(14) 0x0f(15) 0x10(16)

- 10진수에서 2진수로 변환하는 일은 쉽지 않으나, 16진수와 2진수는 변환하기가 편리한다. (0b10001111 =0b1000 1111=0x8f)

## 정수 범위의 비밀
- HEX = 16진수, BIN = 2진수, OCT = 8진수
- 2진수에서 숫자의 최소표현단위 : bit
- byte = 8bit, 0b11111111 = 255이므로 1byte = 0~255까지 표현가능

### 이산수학 - 보수
- 1의 보수 : 가장 좌측의 비트를 단순히 부호의 용도로만 사용하는 방법 
- 1의 보수로 수를 표현할 경우, 두 가지의 방법으로 0을 표현하게 되므로 비효율적인 측면이 있어 사용하지 않는다.
- 2의 보수 : 가장 좌측의 비트를 하나의 음수의 숫자로 사용하는 방법
- 2의 보수 예시 : 0b10000000 = 128이나, 하나의 음수값으로 사용하여 -를 붙인 -128로 계산한다.
- 2의 보수 사용 시 역수 찾는 법 : 해당 수를 역수로 한 뒤, 1을 더한다.
- 역수 찾는 법 예시 : 0b00111000 = 56, 모든 수를 역산한다 : 0b11000111 = -57, 역산한 수에 1을 더한다: 0b11000111+1=0b11001000 = -56

## 불리언(bool)
- 참과 거짓을 나타내는 함수
- "bool (변수명);"을 통해 선언한다.
- 불리언은 참(true, 1)과 거짓(false, 0)의 값만 가질 수 있다. (실제 사용 시 직관을 위해 true, false로만 표현한다)
- 불리언의 크기는 1byte로, 이는 컴퓨터의 연산의 1bit보다 1byte가 훨씬 빠르기 때문이다.

## 소수
- 소수점을 보유한 숫자 (예 : 0.2, 4.2...)
- 소수는 정수와 다르게 이진연산을 하지 않는다.
- 정수에 비해 계산하는 알고리즘이 복잡하므로 메모리를 크게 잡아먹을 수 있다.

### float
-"float (변수명);", "float (변수명) = (값)f;" (f를 입력하지 않을 경우 오류가 난다)
- 4byte 크기의 타입으로 최대 소수점 7자리까지 표현 가능하며, 이후부터는 오차가 발생한다.

### double
- "double (변수명);", "double (변수명) = (값)f" (f를 입력하지 않을 경우 오류가 발생)
- 8byte 크기의 타입으로 float에 비해 정밀도가 뛰어나다.

## char
- 2byte 크기의 타입이다.
- 같은 크기인 short와는 달리 연산의 용도보다는 문자 자체를 저장하는 용도로 사용한다.
- 다만 할당된 용량이 2byte이므로 문자 하나만 저장가능하다.
- "char (변수명);" , "char (변수명) = '(값)';" (값 입력 시 작은따옴표를 사용)

## string
- char의 집합
- "string (변수명);" , "string (변수명) = "(값)"" (값 입력 시 큰따옴표를 사용)

## 형식변환
- 이미 타입이 지정된 데이터를 다른 타입으로 변경하는 것
- 캐스트 : 선언된 타입을 변환하는 일련의 과정

### 용량이 큰 타입에서 작은 타입으로 옮길 경우
- 예시 : int로 선언된 변수를 short(하위용량의 타입)으로 변환하고자 한다.
- int a = 100;, short b = (short)a;

- 캐스트 시 하위타입이 수용가능한 데이터의 양을 상위타입의 변수에서 넘어갈 경우, 데이터가 일부 유실될 수 있음을 주의한다.
- 예시2 : int a = 0x0fffffff; , short b = (short)a;
- 결과 : short b = -1
- 이유 : short는 2바이트의 크기만 저장할 수 있으며, int는 4바이트까지 저장가능하다. 0x0fff/ffff 중에서 0fff와 ffff각각 2바이트식을 차지하는데, short는 2바이트만 저장할 수 있으므로 0fff부분을 날린 0xffff부분만 저장한다. 0xffff = -1이므로 short b의 값이 -1이 되는 것이다.

### 용량이 작은 타입에서 큰 타입으로 옮길 경우
- 예시 : short로 선언된 변수를 int(상위용량의 타입)으로 변환하고자 한다.
- short b = 100;, int a = b;
- 큰 타입에서 작은 타입으로 옮기는 경우와는 달리 별도로 ("타입명")을 적지 않아도 된다.

### 바구니 크기는 같으나, 부호가 다를 경우
- 예시 : 255크기의 byte타입을 sbyte로 변환하고자 한다.
- byte c = 255;, sbyte sd = (sbyte)c; (sd = -1로 변환완료)
- byte였을 때 c의 값은 255로, 0b11111111이다. 그러나 sbyte로 넘어가면서 c(이하 sd)의 값은 여전히 0b11111111로 표현되나, 
sbyte에서는 2의 보수로 표현하므로 -1로 변환되는 결과가 나온다.
- 범위의 초과 / 미달로 인하여 값이 이상한 형태로 변환되는 현상 : 오버플로우(overflow) / 언더플로우(underflow)

### 소수끼리의 타입변환
- 예시 : float로 선언된 값을 double로 변환한다.
- float f = 3.1414f;, double  d = f;
- 결과 : float f = 3.1414, double d = 3.1414000988006592
- 해당 현상에 대한 이유 : 소수는 제시된 값을 정확히 표현하는 것이 아닌, 근접하게 표현하는 것을 목표로 하므로 해당 현상 발생.
- 소수의 경우 예상 범위를 두고 두 수를 예측해야만 예측을 할 수 있음을 알아야 한다.

## 데이터 연산
- 일반 사칙연산과 같이 *, /이 +, -보다 우선순위를 갖는다.
- % = 나머지의 값을 구하는 부호 (예시 : 100%3 = (33*3+1) = 1
- ++ = 해당 변수에 1을 더한다 (예시 : hp++; = ++hp; = hp = hp + 1)
- -- = 해당 변수에 1을 뺀다 (예시 : hp--; = --hp; = hp = hp - 1)
- hp++(--)과 ++(--)hp의 차이 : 1을 더하는 시점을 이전에 할 지, 이후에 할 지를 결정할 수 있다.
- 예시 : int hp = 100;, Console.WriteLine(++hp) (결과값 : 101)
- 예시2 : int hp = 100;, Console.WriteLine(hp++) (결과값 : 100, 다음 시점에 1이 더해진다)

## 비교연산
- "<","<=" : 작다, 작거나 같다
- ">",">=" : 크다, 크거나 같다
- "==", "!=" : 같은가, 다른다
- 비교의 도출 : bool타입을 사용하여 해당 값이 true인지 false인지를 판가름한다.
- 예시: hp변수가 100이고, bool을 이용하여 hp가 100보다 작은지를 확인한다.
- int hp = 100;, bool b = hp < 100; (결과 : false)

## 논리연산
- && : "and", 두 조건이 모두 참이어야 한다. (bool a = isAlive && isHighlevel)
- || : "or", 한 조건만 참이여도 괜찮다. (bool b = isAlive || isHighlevel)
- ! : "not", 조건이 거짓일 경우 참이다. (boo c = !isAlive)

## 비트연산
- 연산자 종류 : "<<", ">>", "&(and)", "|(or)", "^(xor)", "\~(not)"
- "<<" : 1로 표시된 모든 비트를 왼쪽으로 x만큼 옮긴다.
- "<<" 예시 : int num = 1;, num = num<<1; (결과값 : 2)
- ">>" : 1로 표시된 모든 비트를 오른쪽으로 x만큼 옮긴다.
- ">>" 주의 : 만일 음수를 포함하는 타입 중에서 맨 앞자리가 1로 표시되어있을 경우, 기존의 부호는 유지한 채로 (맨 앞자리는 1로 고정) 오른쪽으로 비트가 이동한다. (예 : 0x10000000 (-128) -> 0x11000000)
- "&" : 비트연산, 이진법의 수 a와 b의 각 비트를 사용하여 and연산을 실행한다. 두 수의 비트가 모두 1이면 1로, 둘 중 하나라도 0일 경우 0으로 환산한다.
- "&" 예: a = 0x00110010, b = 0x11100110, a & b = 0x00100010
- "|" : 비트연산, 이진법의 수 a와 b의 각 비트를 사용하여 or연산을 실행한다. 두 수의 비트가 둘 중 하나라도 1이면 1로, 모두 0이면 0으로 표시한다.
- "|" 예: a = 0x00110010, b = 0x11100110, a | b = 0x11110110
- "\~" : 비트연산, 이진법의 수를 역수한다.
- "\~" 예 : a = 0x00111100, a\~ = 0x11000011
- "^" : 비트연산, 이진법의 수 a와 b의 각 비트를 사용하요 xor연산을 실행한다. 두 수의 비트가 다르면 1, 같으면 0으로 표시한다.
- "^" 예 : a = 0x00110010, b = 0x11100110, a ^ b = 0x11010100

- 비트연산의 용도 : 4비트를 활용해서 유저/오브젝트의 id를 만들 때 정보를 입력하는 용도로 사용한다.
- xor의 용도 : 암호화에 사용, xor을 두 번 사용하면 본래의 숫자가 나오도록 유도할 수 있다.
- 예시 : int id = 123;, int key = 401;, int a = id ^ key;, int b = a ^ key
- 예시 결과값 : a = 490, b = 123 (key를 두 번 대입하자, 본래 id의 값이 도출된 것을 확인할 수 있다)

## 할당연산
- 변수를 지정하고, 그 지정된 변수에 값을 할당하는 작업
- 예 : int a;, a = 100; , int b;, b = a (a의 값을 b에 복사)
- 사칙연산 및 비트연산을 줄여서 사용할 수 있다.
- "a += 1;" = "a = a+1;"
- "a -= 1;" = "a = a-1;"
- "a *= 1;" = "a = a*1;"
- "a /= 1;" = "a = a/1;"
- "a %= 1;" = "a = a%1;"
- "a <<= 1;" = "a = a<<1;"
- "a >>= 1;" = "a = a>>1;"
- "a &= 1;" = "a = a&1;"
- "a |= 1;" = "a = a|1;"
- "a ^= 1;" = "a = a^1;"

### 연산자 우선순위
1. ++ --
2. * / %
3. + -
4. << >>
5. < >
6. == !=
7. &
8. ^
9. |
10. 단, 괄호를 사용하여 우선순위를 끌어올릴 수 있다.

### 그 외
- var : 값을 참고하여 올바른 타입을 선언한다.
- 예제 : [var num2 = "hello world"] = [string num2 = "hello world"]
- 단 너무 남용하여 가독성을 떨어뜨리는 일은 지양해야한다.